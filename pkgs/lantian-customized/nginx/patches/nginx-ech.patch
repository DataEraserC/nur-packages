diff --git a/src/event/ngx_event_openssl.c b/src/event/ngx_event_openssl.c
index 9e8f424..32bbe93 100755
--- a/src/event/ngx_event_openssl.c
+++ b/src/event/ngx_event_openssl.c
@@ -9,6 +9,13 @@
 #include <ngx_core.h>
 #include <ngx_event.h>
 
+#ifndef OPENSSL_NO_ECH
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <dirent.h>
+#include <openssl/ech.h>
+#endif
+
 
 #define NGX_SSL_PASSWORD_BUFFER_SIZE  4096
 
@@ -291,7 +298,6 @@ ngx_ssl_init(ngx_log_t *log)
     return NGX_OK;
 }
 
-
 ngx_int_t
 ngx_ssl_create(ngx_ssl_t *ssl, ngx_uint_t protocols, void *data)
 {
@@ -917,6 +923,16 @@ ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
         return NGX_ERROR;
     }
 
+#ifndef OPENSSL_NO_ECH
+    if (SSL_CTX_load_verify_file(ssl->ctx, (char *) cert->data)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_load_verify_file(\"%s\") failed",
+                      cert->data);
+        return NGX_ERROR;
+    }
+#else
     if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
         == 0)
     {
@@ -925,6 +941,7 @@ ngx_ssl_client_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
                       cert->data);
         return NGX_ERROR;
     }
+#endif
 
     /*
      * SSL_CTX_load_verify_locations() may leave errors in the error queue
@@ -964,6 +981,16 @@ ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
         return NGX_ERROR;
     }
 
+#ifndef OPENSSL_NO_ECH
+    if (SSL_CTX_load_verify_file(ssl->ctx, (char *) cert->data)
+        == 0)
+    {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                      "SSL_CTX_load_verify_file(\"%s\") failed",
+                      cert->data);
+        return NGX_ERROR;
+    }
+#else
     if (SSL_CTX_load_verify_locations(ssl->ctx, (char *) cert->data, NULL)
         == 0)
     {
@@ -972,6 +999,7 @@ ngx_ssl_trusted_certificate(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *cert,
                       cert->data);
         return NGX_ERROR;
     }
+#endif
 
     /*
      * SSL_CTX_load_verify_locations() may leave errors in the error queue
@@ -1165,7 +1193,36 @@ ngx_ssl_info_callback(const ngx_ssl_conn_t *ssl_conn, int where, int ret)
             }
         }
     }
+#endif
+
+#ifndef OPENSSL_NO_ECH
+    if ((where & SSL_CB_HANDSHAKE_DONE) == SSL_CB_HANDSHAKE_DONE) {
+        c = ngx_ssl_get_connection((ngx_ssl_conn_t *) ssl_conn);
 
+        char *inner_sni = NULL;
+        char *outer_sni = NULL;
+        int echrv = SSL_ech_get_status(c->ssl->connection, &inner_sni,
+                                       &outer_sni);
+        switch (echrv) {
+        case SSL_ECH_STATUS_NOT_TRIED:
+            ngx_ssl_error(NGX_LOG_INFO, c->log, 0, "ECH not attempted");
+            break;
+        case SSL_ECH_STATUS_FAILED:
+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0, "ECH tried but failed");
+            break;
+        case SSL_ECH_STATUS_BAD_NAME:
+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0, "ECH worked but bad name");
+            break;
+        case SSL_ECH_STATUS_SUCCESS:
+            ngx_ssl_error(NGX_LOG_NOTICE, c->log, 0,
+                    "ECH success outer_sni: %s inner_sni: %s",
+                    (outer_sni?outer_sni:"NONE"),(inner_sni?inner_sni:"NONE"));
+            break;
+        default:
+            ngx_ssl_error(NGX_LOG_ERR, c->log, 0, "Error getting ECH status");
+            break;
+        }
+    }
 #endif
 
     if ((where & SSL_CB_ACCEPT_LOOP) == SSL_CB_ACCEPT_LOOP) {
@@ -1403,6 +1460,129 @@ ngx_ssl_passwords_cleanup(void *data)
     }
 }
 
+#ifndef OPENSSL_NO_ECH
+
+/* 
+ * load any key files called <name>.ech we find in the ssl_echkeydir 
+ * directory 
+ */
+static int load_echkeys(ngx_ssl_t *ssl, ngx_str_t *dirname)
+{
+    /*
+     * Try load any good looking public/private ECH values found in files
+     * in that directory
+     *
+     * This code is derived from what I added to openssl s_server, (and
+     * then lighttpd)
+     *
+     */
+    ngx_dir_t thedir;
+    ngx_int_t nrv = ngx_open_dir(dirname, &thedir);
+    char privname[PATH_MAX];
+    int somekeyworked = 0;
+    /*
+     * I really can't see a reason to want >1024 private key files
+     * to have to be checked in a directory, but if there were a
+     * reason then you could change this I guess or make it a 
+     * config setting.
+     */
+    int maxkeyfiles=1024;
+    size_t elen=dirname->len;
+    char *den = NULL, *last4 = NULL;
+    size_t nlen = 0;
+    struct stat thestat;
+    int numkeys = 0;
+
+    if (nrv != NGX_OK) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+            "load_echkeys, error opening %s at %d", dirname->data, __LINE__);
+        return NGX_ERROR;
+    }
+    for (;;) {
+        nrv=ngx_read_dir(&thedir);
+        if (nrv!=NGX_OK) {
+            break;
+        }
+        den = (char *)ngx_de_name(&thedir);
+        nlen = strlen(den);
+        if (nlen > 4) {
+            last4 = den + nlen - 4;
+            if (strncmp(last4, ".ech", 4)) {
+                continue;
+            }
+            if ((elen + 1 + nlen + 1) >= PATH_MAX) {
+                ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0,
+                    "load_echkeys, error, name too long: %s with %s",
+                    dirname->data, den);
+                continue;
+            }
+            snprintf(privname, PATH_MAX,"%s/%s", dirname->data, den);
+            if (!--maxkeyfiles) {
+                // just so we don't loop forever, ever
+                ngx_ssl_error(NGX_LOG_ALERT, ssl->log, 0,
+                    "load_echkeys, too many private key files to check!");
+                ngx_ssl_error(NGX_LOG_ALERT, ssl->log, 0,
+                    "load_echkeys, maxkeyfiles is hardcoded to 1024, fix if you like!");
+                 return NGX_ERROR;
+            }
+            if (stat(privname, &thestat) == 0) {
+                    if (SSL_CTX_ech_server_enable_file(ssl->ctx, privname,
+                        SSL_ECH_USE_FOR_RETRY) != 1) {
+                    ngx_ssl_error(NGX_LOG_ALERT, ssl->log, 0,
+                        "load_echkeys, failed for: %s",privname);
+                } else {
+                    ngx_ssl_error(NGX_LOG_NOTICE, ssl->log, 0,
+                        "load_echkeys, worked for: %s", privname);
+                    somekeyworked = 1;
+                }
+            }
+        }
+    }
+    ngx_close_dir(&thedir);
+
+    if (somekeyworked == 0) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, 
+            "load_echkeys failed for all keys but ECH configured");
+        return NGX_ERROR;
+    }
+
+    if (SSL_CTX_ech_server_get_key_status(ssl->ctx, &numkeys) != 1) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, 
+            "load_echkeys SSL_CTX_ech_server_key_status failed");
+        return NGX_ERROR;
+    }
+    ngx_ssl_error(NGX_LOG_NOTICE, ssl->log, 0, 
+            "load_echkeys, total keys loaded: %d", numkeys);
+
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_ssl_echkeydir(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *dir)
+{
+    int rv = 0;
+
+    if (!dir) {
+        return NGX_OK;
+    }
+    if (dir->len == 0) {
+        return NGX_OK;
+    }
+    if (cf != NULL && ngx_conf_full_name(cf->cycle, dir, 1) != NGX_OK) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, 
+                "Hey some bad ech stuff happened at %d",__LINE__);
+        return NGX_ERROR;
+    }
+    rv = load_echkeys(ssl, dir);
+    if (rv!=NGX_OK) {
+        ngx_ssl_error(NGX_LOG_EMERG, ssl->log, 0, 
+                "Hey some bad ech stuff happened at %d",__LINE__);
+        return rv;
+    }
+    return NGX_OK;
+}
+
+#endif
 
 ngx_int_t
 ngx_ssl_dhparam(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *file)
@@ -3745,7 +3925,11 @@ ngx_ssl_error(ngx_uint_t level, ngx_log_t *log, ngx_err_t err, char *fmt, ...)
 
         for ( ;; ) {
 
-            n = ERR_peek_error_data(&data, &flags);
+#ifndef OPENSSL_NO_ECH
+            n = ERR_peek_last_error_data(&data, &flags);
+#else
+            n = ERR_peek_error_line_data(NULL, NULL, &data, &flags);
+#endif
 
             if (n == 0) {
                 break;
@@ -5123,6 +5307,76 @@ ngx_ssl_get_cipher_name(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
     return NGX_OK;
 }
 
+#ifndef OPENSSL_NO_ECH
+ngx_int_t
+ngx_ssl_get_ech_status(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    char *inner_sni;
+    char *outer_sni;
+    char buf[PATH_MAX];
+    int echrv=SSL_ech_get_status(c->ssl->connection,&inner_sni,&outer_sni);
+    switch (echrv) {
+    case SSL_ECH_STATUS_NOT_TRIED:
+        snprintf(buf,PATH_MAX,"not attempted");
+        break;
+    case SSL_ECH_STATUS_FAILED:
+        snprintf(buf, PATH_MAX, "tried but failed");
+        break;
+    case SSL_ECH_STATUS_BAD_NAME:
+        snprintf(buf, PATH_MAX,"worked but bad name");
+        break;
+    case SSL_ECH_STATUS_SUCCESS:
+        snprintf(buf, PATH_MAX, "success");
+        break;
+    default:
+        snprintf(buf, PATH_MAX, "error getting ECH status");
+        break;
+    }
+    s->len = ngx_strlen(buf);
+    s->data = ngx_pnalloc(pool, s->len);
+    ngx_memcpy(s->data,buf,s->len);
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_ssl_get_ech_inner_sni(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    char *inner_sni;
+    char *outer_sni;
+    int echrv=SSL_ech_get_status(c->ssl->connection,&inner_sni,&outer_sni);
+    if (echrv==SSL_ECH_STATUS_SUCCESS && inner_sni) {
+        s->len=strlen(inner_sni);
+        s->data = ngx_pnalloc(pool, s->len);
+        ngx_memcpy(s->data,inner_sni,s->len);
+    } else {
+        s->len = ngx_strlen("NONE");
+        s->data = ngx_pnalloc(pool, s->len);
+        ngx_memcpy(s->data,"NONE",s->len);
+    }
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_ssl_get_ech_outer_sni(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
+{
+    char *inner_sni;
+    char *outer_sni;
+    int echrv=SSL_ech_get_status(c->ssl->connection,&inner_sni,&outer_sni);
+    if (echrv==SSL_ECH_STATUS_SUCCESS && outer_sni) {
+        s->len=strlen(outer_sni);
+        s->data = ngx_pnalloc(pool, s->len);
+        ngx_memcpy(s->data,outer_sni,s->len);
+    } else {
+        s->len = ngx_strlen("NONE");
+        s->data = ngx_pnalloc(pool, s->len);
+        ngx_memcpy(s->data,"NONE",s->len);
+    }
+
+    return NGX_OK;
+}
+
+#endif
+
 
 ngx_int_t
 ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool, ngx_str_t *s)
diff --git a/src/event/ngx_event_openssl.h b/src/event/ngx_event_openssl.h
index ebb2c35..8acda37 100755
--- a/src/event/ngx_event_openssl.h
+++ b/src/event/ngx_event_openssl.h
@@ -39,6 +39,9 @@
 #include <openssl/rand.h>
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
+#ifndef OPENSSL_NO_ECH
+#include <openssl/ech.h>
+#endif
 
 #define NGX_SSL_NAME     "OpenSSL"
 
@@ -240,6 +243,9 @@ ngx_int_t ngx_ssl_session_cache_init(ngx_shm_zone_t *shm_zone, void *data);
 
 ngx_int_t ngx_ssl_create_connection(ngx_ssl_t *ssl, ngx_connection_t *c,
     ngx_uint_t flags);
+#ifndef OPENSSL_NO_ECH
+ngx_int_t ngx_ssl_echkeydir(ngx_conf_t *cf, ngx_ssl_t *ssl, ngx_str_t *dir);
+#endif
 
 void ngx_ssl_remove_cached_session(SSL_CTX *ssl, ngx_ssl_session_t *sess);
 ngx_int_t ngx_ssl_set_session(ngx_connection_t *c, ngx_ssl_session_t *session);
@@ -269,6 +275,14 @@ ngx_int_t ngx_ssl_get_ciphers(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
 ngx_int_t ngx_ssl_get_curve(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
+#ifndef OPENSSL_NO_ECH
+ngx_int_t ngx_ssl_get_ech_status(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_ech_inner_sni(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+ngx_int_t ngx_ssl_get_ech_outer_sni(ngx_connection_t *c, ngx_pool_t *pool,
+    ngx_str_t *s);
+#endif
 ngx_int_t ngx_ssl_get_curves(ngx_connection_t *c, ngx_pool_t *pool,
     ngx_str_t *s);
 ngx_int_t ngx_ssl_get_session_id(ngx_connection_t *c, ngx_pool_t *pool,
diff --git a/src/http/modules/ngx_http_ssl_module.c b/src/http/modules/ngx_http_ssl_module.c
index 1c92d9f..ae24b6a 100755
--- a/src/http/modules/ngx_http_ssl_module.c
+++ b/src/http/modules/ngx_http_ssl_module.c
@@ -13,7 +13,6 @@
 #include <ngx_event_quic_openssl_compat.h>
 #endif
 
-
 typedef ngx_int_t (*ngx_ssl_variable_handler_pt)(ngx_connection_t *c,
     ngx_pool_t *pool, ngx_str_t *s);
 
@@ -199,6 +198,15 @@ static ngx_command_t  ngx_http_ssl_commands[] = {
       offsetof(ngx_http_ssl_srv_conf_t, session_tickets),
       NULL },
 
+#ifndef OPENSSL_NO_ECH
+    { ngx_string("ssl_echkeydir"),
+      NGX_HTTP_MAIN_CONF|NGX_CONF_TAKE1,
+      ngx_conf_set_str_slot,
+      NGX_HTTP_SRV_CONF_OFFSET,
+      offsetof(ngx_http_ssl_srv_conf_t, echkeydir),
+      NULL },
+#endif
+
     { ngx_string("ssl_session_ticket_key"),
       NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_CONF_TAKE1,
       ngx_conf_set_str_array_slot,
@@ -338,6 +346,14 @@ static ngx_http_variable_t  ngx_http_ssl_vars[] = {
 
     { ngx_string("ssl_curve"), NULL, ngx_http_ssl_variable,
       (uintptr_t) ngx_ssl_get_curve, NGX_HTTP_VAR_CHANGEABLE, 0 },
+#ifndef OPENSSL_NO_ECH
+    { ngx_string("ssl_ech_status"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_ech_status, NGX_HTTP_VAR_CHANGEABLE, 0 },
+    { ngx_string("ssl_ech_inner_sni"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_ech_inner_sni, NGX_HTTP_VAR_CHANGEABLE, 0 },
+    { ngx_string("ssl_ech_outer_sni"), NULL, ngx_http_ssl_variable,
+      (uintptr_t) ngx_ssl_get_ech_outer_sni, NGX_HTTP_VAR_CHANGEABLE, 0 },
+#endif
 
     { ngx_string("ssl_curves"), NULL, ngx_http_ssl_variable,
       (uintptr_t) ngx_ssl_get_curves, NGX_HTTP_VAR_CHANGEABLE, 0 },
@@ -609,6 +625,9 @@ ngx_http_ssl_create_srv_conf(ngx_conf_t *cf)
      *     sscf->ocsp_responder = { 0, NULL };
      *     sscf->stapling_file = { 0, NULL };
      *     sscf->stapling_responder = { 0, NULL };
+     *     #ifndef OPENSSL_NO_ECH
+     *     sscf->echkeydir = { 0, NULL} ;
+     *     #endif
      */
 
     sscf->prefer_server_ciphers = NGX_CONF_UNSET;
@@ -669,6 +688,9 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
     ngx_conf_merge_ptr_value(conf->passwords, prev->passwords, NULL);
 
     ngx_conf_merge_str_value(conf->dhparam, prev->dhparam, "");
+#ifndef OPENSSL_NO_ECH
+    ngx_conf_merge_str_value(conf->echkeydir, prev->echkeydir, "");
+#endif
 
     ngx_conf_merge_str_value(conf->client_certificate, prev->client_certificate,
                          "");
@@ -835,6 +857,12 @@ ngx_http_ssl_merge_srv_conf(ngx_conf_t *cf, void *parent, void *child)
         return NGX_CONF_ERROR;
     }
 
+#ifndef OPENSSL_NO_ECH
+    if (ngx_ssl_echkeydir(cf, &conf->ssl, &conf->echkeydir) != NGX_OK) {
+        return NGX_CONF_ERROR;
+    }
+#endif
+
     if (ngx_ssl_ecdh_curve(cf, &conf->ssl, &conf->ecdh_curve) != NGX_OK) {
         return NGX_CONF_ERROR;
     }
diff --git a/src/http/modules/ngx_http_ssl_module.h b/src/http/modules/ngx_http_ssl_module.h
index c69c8ff..5af48f3 100755
--- a/src/http/modules/ngx_http_ssl_module.h
+++ b/src/http/modules/ngx_http_ssl_module.h
@@ -13,7 +13,6 @@
 #include <ngx_core.h>
 #include <ngx_http.h>
 
-
 typedef struct {
     ngx_ssl_t                       ssl;
 
@@ -39,6 +38,9 @@ typedef struct {
     ngx_array_t                    *certificate_key_values;
 
     ngx_str_t                       dhparam;
+#ifndef OPENSSL_NO_ECH
+    ngx_str_t                       echkeydir;
+#endif
     ngx_str_t                       ecdh_curve;
     ngx_str_t                       client_certificate;
     ngx_str_t                       trusted_certificate;
